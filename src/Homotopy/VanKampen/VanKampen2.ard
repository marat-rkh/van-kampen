\import Equiv (Equiv, QEquiv)
\import Equiv.Sigma
\import Function.Meta
\import Homotopy.Pushout
\import Homotopy.VanKampen.Ext.Equiv
\import Homotopy.VanKampen.Ext.Paths
\import Homotopy.VanKampen.Ext.Pushout
\import Homotopy.VanKampen.Paths0
\import Homotopy.VanKampen.VanKampen
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
-- TODO false positive
\open VanKampen (:cb:, CodeB, CodeC)
\open PushoutData (ppglue)

\class VanKampen2 \noclassifying {A B C : \Type} (f : A -> B) (g : A -> C) {
  \func vk (b : B) => \new VanKampen f g b

  \func vk-flip (c : C) => \new VanKampen g f c

  \func b-code (b : B) (po : PushoutData f g) => VanKampen.code {vk b} po

  \func c-code (c : C) (po : PushoutData f g) => VanKampen.code {vk-flip c} (flip po)

  \func code2 (po1 po2 : PushoutData f g) : \Set
    | pinl b1, po2 => b-code b1 po2
    | pinr c1, po2 => c-code c1 po2
    | pglue a1, po2 => equiv= $ b-code-equiv-c-code a1 po2
    \where {
      -- TODO false positive
      \open CodeB
      \open CodeC

      \func vk (b : B) => \new VanKampen f g b

      \func vk-flip (c : C) => \new VanKampen g f c

      \func b-code (b : B) (po : PushoutData f g) => VanKampen.code {vk b} po

      \func c-code (c : C) (po : PushoutData f g) => VanKampen.code {vk-flip c} (flip po)

      -- TODO can we replace Equiv with QEquiv here? Because both equiv-b and equiv-c are QEquiv.
      \func b-code-equiv-c-code (a : A) (po : PushoutData f g) : Equiv {b-code (f a) po} {c-code (g a) po} \elim po
        | pinl b => equiv-b
        | pinr c => equiv-c
        | pglue a2 => pathOver (transport_Equiv {PushoutData f g} {b-code (f a) __} {c-code (g a) __} (ppglue a2) pglue-lemma)
        \where {
          \func equiv-b {a : A} {b : B} : QEquiv {b-code (f a) (pinl b)} {c-code (g a) (pinl b)} \cowith
            | f => idp:cc: vk vk-flip
            | ret => idp:bb: vk vk-flip
            | ret_f => idp-idp-code-b=code-b vk vk-flip
            | f_sec => idp-idp-code-c=code-c vk vk-flip

          \func equiv-c {a : A} {c : C} : QEquiv {b-code (f a) (pinr c)} {c-code (g a) (pinr c)} \cowith
            | f => idp:bb: vk-flip vk
            | ret => idp:cc: vk-flip vk
            | ret_f => idp-idp-code-c=code-c vk-flip vk
            | f_sec => idp-idp-code-b=code-b vk-flip vk

          \func idp:cc: {A B C : \Type} {f : A -> B} {g : A -> C}
                        (vk : ∀ b0 (VanKampen f g b0)) (vk-flip : ∀ c0 (VanKampen g f c0))
                        {a : A} {b : B} (co : VanKampen.CodeB {vk (f a)} b) : VanKampen.CodeC {vk-flip (g a)} b \elim co
            | bb p => bb idp :cc: p
            | co :bb: (q, p) => idp:cc: vk vk-flip co :cb: {vk-flip _} q :cc: p
            | bb-quot1 p1 p2 => cc-quot {vk-flip _} _ _ _
            | bb-quot2 co q p1 p2 => cc-quot {vk-flip _} _ _ _
            -- TODO proofs look exactly the same, there should be a tactic like mcases for this
            | bb-quot3 (bb p0) q1 q2 p => pmap (__ :cc: {vk-flip _} p) (path (bb-quot2 {vk-flip _} _ _ _ _))
            | bb-quot3 (co :bb: (q0, p0)) q1 q2 p => pmap (__ :cc: {vk-flip _} p) (path (bb-quot2 {vk-flip _} _ _ _ _))

          \func idp:bb: {A B C : \Type} {f : A -> B} {g : A -> C}
                        (vk : ∀ b0 (VanKampen f g b0)) (vk-flip : ∀ c0 (VanKampen g f c0))
                        {a1 : A} {b : B} (co : VanKampen.CodeC {vk-flip (g a1)} b) : VanKampen.CodeB {vk (f a1)} b \elim co
            | co :cc: p => idp:cc: vk-flip vk co :cb: {vk _} p
            -- TODO proofs look exactly the same, there should be a tactic like mcases for this
            | cc-quot (bb p) q1 q2 => path (bb-quot2 {vk _} _ _ _ _)
            | cc-quot (co :bb: (q0, p)) q1 q2 => path (bb-quot2 {vk _} _ _ _ _)

          \func idp-idp-code-b=code-b {A B C : \Type} {f : A -> B} {g : A -> C}
                                      (vk : ∀ b0 (VanKampen f g b0)) (vk-flip : ∀ c0 (VanKampen g f c0))
                                      {a : A} {b : B} (co : VanKampen.CodeB {vk (f a)} b)
            : idp:bb: vk vk-flip (idp:cc: vk vk-flip co) = co \elim co
            | bb p => path (bb-quot1 {vk _} _ _) *> rewrite (idp_*> _) idp
            | co :bb: (q, p) => idp:cc:-:cb:-lemma1 vk vk-flip co q p

          \func idp:cc:-:cb:-lemma1 {A B C : \Type} {f : A -> B} {g : A -> C}
                                    (vk : ∀ b0 (VanKampen f g b0)) (vk-flip : ∀ c0 (VanKampen g f c0))
                                    {a1 a2 a3 : A} {b : B}
                                    (co : VanKampen.CodeB {vk (f a1)} (f a2)) (q : g a2 = g a3) (p : f a3 = b)
            : idp:cc: vk-flip vk (idp:cc: vk vk-flip co :cb: {vk-flip _} q) :cb: {vk _} p = co :bb: (q, p) \elim co
            | bb p0 => pmap (__ :bb: {vk _} (q, p)) (path (bb-quot1 {vk _} _ _)) *> rewrite (idp_*> _) idp
            | co :bb: (q0, p0) => pmap (__ :bb: {vk _} (q, p)) (idp:cc:-:cb:-lemma1 vk vk-flip _ _ _)

          \func idp-idp-code-c=code-c {A B C : \Type} {f : A -> B} {g : A -> C}
                                      (vk : ∀ b0 (VanKampen f g b0)) (vk-flip : ∀ c0 (VanKampen g f c0))
                                      {a : A} {b : B} (co : VanKampen.CodeC {vk-flip (g a)} b)
            : idp:cc: vk vk-flip (idp:bb: vk vk-flip co) = co \elim co
            | co :cc: p => idp:cc:-:cb:-lemma2 vk vk-flip _ _

          \func idp:cc:-:cb:-lemma2 {A B C : \Type} {f : A -> B} {g : A -> C}
                                    (vk : ∀ b0 (VanKampen f g b0)) (vk-flip : ∀ c0 (VanKampen g f c0))
                                    {a1 a2 : A} {b : B}
                                    (co : VanKampen.CodeB {vk-flip (g a1)} (g a2)) (p : f a2 = b)
            : idp:cc: vk vk-flip (idp:cc: vk-flip vk co :cb: {vk _} p) = co :cc: p \elim co
            | bb p0 => pmap (__ :cc: {vk-flip _} p) (path (bb-quot1 {vk-flip _} _ _)) *> rewrite (idp_*> _) idp
            | co :bb: (q0, p0) => pmap (__ :cc: {vk-flip _} p) (idp:cc:-:cb:-lemma1 vk-flip vk _ _ _)

          \func pglue-lemma {a1 a2 : A} (co : b-code (f a1) (pinl (f a2)))
            : transport (c-code (g a1)) (ppglue a2) (equiv-b co) = equiv-c (transport (b-code (f a1)) (ppglue a2) co) =>
            run {
              rewrite (VanKampen.transport-code-b-pglue {vk _} a2 _),
              rewrite (transport-code-c-inv-pglue (equiv-b co)),
              rewrite (VanKampen.:bb:idp=:cb:idp {vk-flip _} _) idp
            }

          \func transport-code-c-inv-pglue {c : C} {a : A} (co : c-code c (pinl (f a)))
            : transport (c-code c) (ppglue a) co = VanKampen.:bb:idp {vk-flip _} co \elim co
            | :cc: {a'} co q => VanKampen.transport-code-c-inv-pglue {vk-flip c} a' a co q
        }
    }

  -- https://github.com/HoTT/HoTT-Agda/blob/1.0/Homotopy/VanKampen.agda
  \func encode (po1 po2 : PushoutData f g) (p : po1 =0 po2) : code2 po1 po2 => transport0 (code2 po1) p (idp-code2 po1)

  \func idp-code2 (po : PushoutData f g) : code2 po po
    | pinl b => VanKampen.idp-code {vk b}
    | pinr c => VanKampen.idp-code {vk-flip c}
    -- TODO If you replace the argument of pathOver with {?} the typechecker shows a very cryptic type. Why?
    | pglue a => pathOver transport-code2-idp-code

  \func transport-code2-idp-code {a : A}
    : transport (\lam po => code2 po po) (ppglue a) (VanKampen.idp-code {vk (f a)}) = VanKampen.idp-code {vk-flip (g a)} =>
    run {
      rewrite (transport-diag code2 (ppglue a) _),
      rewrite (VanKampen.transport-code-b-pglue {vk _} a (VanKampen.idp-code {vk (f a)})),
      {?}
    }
}